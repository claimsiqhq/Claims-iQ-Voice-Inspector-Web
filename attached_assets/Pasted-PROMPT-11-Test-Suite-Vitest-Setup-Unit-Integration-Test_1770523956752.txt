PROMPT-11 — Test Suite: Vitest Setup + Unit & Integration Tests
Context
The Claims IQ Voice Inspector codebase has zero test coverage — no test framework, no test scripts, no test files. This prompt bootstraps a full test suite using Vitest (the natural fit for a Vite + TypeScript + ESM project). The tests target the three core server modules that contain pure or near-pure business logic:
ModuleFileWhy TestEstimate Engineserver/estimateEngine.tsAll pricing math, O&P threshold, companion suggestions, validationESX Generatorserver/esxGenerator.tsXactimate-compatible XML structure, ZIP packaging, room groupingPDF Generatorserver/pdfGenerator.tsBuffer output, section rendering, brand consistency
The tests mock IStorage (from server/storage.ts) so they run without a database.
Prerequisite: PROMPT-10 should be applied first. The tests below cover both the pre-patch and post-patch signatures. Where PROMPT-10 adds new parameters (e.g., overheadPctOverride), the tests validate them.

STEP 1: Install Dependencies
bashnpm install --save-dev vitest @vitest/coverage-v8
No other test dependencies needed — Vitest includes its own assertion library, mocking, and TypeScript support.

STEP 2: Create vitest.config.ts (project root)
This file must mirror the path aliases from vite.config.ts and tsconfig.json:
typescriptimport { defineConfig } from 'vitest/config';
import path from 'path';

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    include: ['test/**/*.test.ts'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      include: ['server/estimateEngine.ts', 'server/esxGenerator.ts', 'server/pdfGenerator.ts'],
    },
    // Increase timeout for PDF generation tests
    testTimeout: 10000,
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, 'client', 'src'),
      '@shared': path.resolve(__dirname, 'shared'),
    },
  },
});

STEP 3: Add Scripts to package.json
Add these three entries to the "scripts" block:
json"test": "vitest run",
"test:watch": "vitest",
"test:coverage": "vitest run --coverage"

STEP 4: Create Directory Structure
test/
├── mocks/
│   ├── storage.mock.ts      ← IStorage mock factory
│   └── fixtures.ts           ← Reusable test data
├── estimateEngine.test.ts    ← Pricing math tests
├── esxGenerator.test.ts      ← XML/ZIP structure tests
└── pdfGenerator.test.ts      ← PDF buffer tests

STEP 5: Mock Factory — test/mocks/storage.mock.ts
This creates a full mock of IStorage where every method is a vi.fn() that returns a sensible default. Tests override specific methods per scenario.
typescriptimport { vi } from 'vitest';
import type { IStorage } from '../../server/storage';

/**
 * Creates a fully-mocked IStorage where every method is a vi.fn().
 * Override individual methods in your tests as needed.
 */
export function createMockStorage(overrides: Partial<IStorage> = {}): IStorage {
  const mock: IStorage = {
    // User
    getUser: vi.fn().mockResolvedValue(undefined),
    getUserByUsername: vi.fn().mockResolvedValue(undefined),
    getUserBySupabaseId: vi.fn().mockResolvedValue(undefined),
    createUser: vi.fn().mockResolvedValue({ id: 'user-1', username: 'test' }),
    syncSupabaseUser: vi.fn().mockResolvedValue({ id: 'user-1' }),
    updateUserLastLogin: vi.fn().mockResolvedValue(undefined),
    getAllUsers: vi.fn().mockResolvedValue([]),

    // Claims
    createClaim: vi.fn().mockResolvedValue({ id: 1 }),
    getClaimsForUser: vi.fn().mockResolvedValue([]),
    getClaims: vi.fn().mockResolvedValue([]),
    getClaim: vi.fn().mockResolvedValue(undefined),
    deleteClaim: vi.fn().mockResolvedValue(true),
    deleteAllClaims: vi.fn().mockResolvedValue(0),
    updateClaimStatus: vi.fn().mockResolvedValue(undefined),
    updateClaimFields: vi.fn().mockResolvedValue(undefined),

    // Documents
    getAllDocuments: vi.fn().mockResolvedValue([]),
    getDocumentById: vi.fn().mockResolvedValue(undefined),
    createDocument: vi.fn().mockResolvedValue({ id: 1 }),
    getDocuments: vi.fn().mockResolvedValue([]),
    getDocument: vi.fn().mockResolvedValue(undefined),
    updateDocumentStatus: vi.fn().mockResolvedValue(undefined),
    updateDocumentStoragePath: vi.fn().mockResolvedValue(undefined),
    updateDocumentError: vi.fn().mockResolvedValue(undefined),

    // Extractions
    createExtraction: vi.fn().mockResolvedValue({ id: 1 }),
    getExtractions: vi.fn().mockResolvedValue([]),
    getExtraction: vi.fn().mockResolvedValue(undefined),
    updateExtraction: vi.fn().mockResolvedValue(undefined),
    confirmExtraction: vi.fn().mockResolvedValue(undefined),

    // Briefings
    createBriefing: vi.fn().mockResolvedValue({ id: 1 }),
    getBriefing: vi.fn().mockResolvedValue(undefined),

    // Sessions
    createInspectionSession: vi.fn().mockResolvedValue({ id: 1 }),
    getInspectionSession: vi.fn().mockResolvedValue(undefined),
    getInspectionSessionsForClaim: vi.fn().mockResolvedValue([]),
    getActiveSessionForClaim: vi.fn().mockResolvedValue(undefined),
    updateSessionPhase: vi.fn().mockResolvedValue(undefined),
    updateSessionRoom: vi.fn().mockResolvedValue(undefined),
    updateSessionStatus: vi.fn().mockResolvedValue(undefined),
    updateSession: vi.fn().mockResolvedValue(undefined),
    completeSession: vi.fn().mockResolvedValue(undefined),

    // Rooms
    createRoom: vi.fn().mockResolvedValue({ id: 1 }),
    getRooms: vi.fn().mockResolvedValue([]),
    getRoom: vi.fn().mockResolvedValue(undefined),
    getRoomByName: vi.fn().mockResolvedValue(undefined),
    updateRoomStatus: vi.fn().mockResolvedValue(undefined),
    completeRoom: vi.fn().mockResolvedValue(undefined),
    incrementRoomDamageCount: vi.fn().mockResolvedValue(undefined),
    incrementRoomPhotoCount: vi.fn().mockResolvedValue(undefined),

    // Damages
    createDamage: vi.fn().mockResolvedValue({ id: 1 }),
    getDamages: vi.fn().mockResolvedValue([]),
    getDamagesForSession: vi.fn().mockResolvedValue([]),

    // Line Items
    createLineItem: vi.fn().mockResolvedValue({ id: 1 }),
    getLineItems: vi.fn().mockResolvedValue([]),
    getLineItemsForRoom: vi.fn().mockResolvedValue([]),
    getEstimateSummary: vi.fn().mockResolvedValue({ totalRCV: 0, totalDepreciation: 0, totalACV: 0, itemCount: 0 }),
    updateLineItem: vi.fn().mockResolvedValue(undefined),
    deleteLineItem: vi.fn().mockResolvedValue(undefined),

    // Photos
    createPhoto: vi.fn().mockResolvedValue({ id: 1 }),
    getPhotos: vi.fn().mockResolvedValue([]),
    getPhotosForRoom: vi.fn().mockResolvedValue([]),
    updatePhoto: vi.fn().mockResolvedValue(undefined),

    // Moisture
    createMoistureReading: vi.fn().mockResolvedValue({ id: 1 }),
    getMoistureReadings: vi.fn().mockResolvedValue([]),
    getMoistureReadingsForSession: vi.fn().mockResolvedValue([]),

    // Transcripts
    addTranscript: vi.fn().mockResolvedValue({ id: 1 }),
    getTranscript: vi.fn().mockResolvedValue([]),

    // Pricing catalog
    getScopeLineItems: vi.fn().mockResolvedValue([]),
    getScopeLineItemByCode: vi.fn().mockResolvedValue(undefined),
    getScopeLineItemsByTrade: vi.fn().mockResolvedValue([]),
    getRegionalPrice: vi.fn().mockResolvedValue(undefined),
    getRegionalPricesForRegion: vi.fn().mockResolvedValue([]),

    // Supplementals
    createSupplementalClaim: vi.fn().mockResolvedValue({ id: 1 }),
    getSupplementalsForSession: vi.fn().mockResolvedValue([]),
    getSupplemental: vi.fn().mockResolvedValue(undefined),
    updateSupplemental: vi.fn().mockResolvedValue(undefined),
    submitSupplemental: vi.fn().mockResolvedValue(undefined),
    approveSupplemental: vi.fn().mockResolvedValue(undefined),

    // User settings & profile
    updateUserProfile: vi.fn().mockResolvedValue(undefined),
    getUserSettings: vi.fn().mockResolvedValue(null),
    upsertUserSettings: vi.fn().mockResolvedValue({ id: 1, userId: 'user-1', settings: {} }),

    // Apply overrides
    ...overrides,
  };

  return mock;
}

STEP 6: Test Fixtures — test/mocks/fixtures.ts
Reusable mock data that mirrors real Verisk catalog shapes.
typescript/**
 * Mock catalog item — matches the shape returned by db.select().from(scopeLineItems)
 */
export function makeCatalogItem(overrides: Record<string, any> = {}) {
  return {
    id: 1,
    code: 'DRY-12-SF',
    description: '1/2" drywall - hung, taped, floated, ready for paint',
    unit: 'SF',
    tradeCode: 'DRY',
    defaultWasteFactor: 10,
    laborMinimum: null,
    isActive: true,
    createdAt: new Date(),
    ...overrides,
  };
}

/**
 * Mock regional price — matches the shape returned by db.select().from(regionalPriceSets)
 */
export function makeRegionalPrice(overrides: Record<string, any> = {}) {
  return {
    id: 1,
    lineItemCode: 'DRY-12-SF',
    regionId: 'US_NATIONAL',
    materialCost: 0.52,
    laborCost: 0.92,
    equipmentCost: 0.06,
    totalUnitPrice: 1.50,
    effectiveDate: '2025-01-01',
    source: 'verisk',
    createdAt: new Date(),
    ...overrides,
  };
}

/**
 * Helper to build a PricedLineItem for calculateEstimateTotals tests.
 * Accepts just the fields that matter for totals calculation.
 */
export function makePricedItem(overrides: Record<string, any> = {}) {
  return {
    code: 'DRY-12-SF',
    description: '1/2" drywall',
    unit: 'SF',
    quantity: 100,
    unitPriceBreakdown: {
      materialCost: 0.572,   // 0.52 × 1.10 (10% waste)
      laborCost: 1.012,      // 0.92 × 1.10
      equipmentCost: 0.066,  // 0.06 × 1.10
      wasteFactor: 10,
      unitPrice: 1.65,       // (0.52+0.92+0.06) × 1.10
    },
    totalPrice: 165.0,       // 1.65 × 100
    tradeCode: 'DRY',
    ...overrides,
  };
}

/**
 * Mock claim object
 */
export function makeClaim(overrides: Record<string, any> = {}) {
  return {
    id: 1,
    claimNumber: 'CLM-2025-001',
    insuredName: 'Jane Smith',
    propertyAddress: '123 Main St',
    city: 'Austin',
    state: 'TX',
    zip: '78701',
    dateOfLoss: '2025-01-15',
    perilType: 'water',
    status: 'in_progress',
    createdAt: new Date(),
    assignedTo: 'user-1',
    ...overrides,
  };
}

/**
 * Mock inspection session
 */
export function makeSession(overrides: Record<string, any> = {}) {
  return {
    id: 1,
    claimId: 1,
    status: 'active',
    currentPhase: 1,
    currentRoomId: null,
    startedAt: new Date(),
    completedAt: null,
    createdAt: new Date(),
    ...overrides,
  };
}

/**
 * Mock inspection room
 */
export function makeRoom(overrides: Record<string, any> = {}) {
  return {
    id: 1,
    sessionId: 1,
    name: 'Kitchen',
    structure: 'Main',
    roomType: 'kitchen',
    status: 'completed',
    dimensions: { length: 12, width: 10, height: 8 },
    damageCount: 2,
    photoCount: 3,
    createdAt: new Date(),
    ...overrides,
  };
}

/**
 * Mock line item (as stored in DB)
 */
export function makeLineItem(overrides: Record<string, any> = {}) {
  return {
    id: 1,
    sessionId: 1,
    roomId: 1,
    description: '1/2" drywall - hung, taped, floated',
    category: 'Drywall',
    action: 'R&R',
    quantity: 100,
    unit: 'SF',
    unitPrice: 1.65,
    totalPrice: 165.0,
    xactCode: 'DRY-12-SF',
    depreciation: 16.5,
    depreciationType: 'Recoverable',
    source: 'voice_agent',
    createdAt: new Date(),
    ...overrides,
  };
}

/**
 * Mock damage observation
 */
export function makeDamage(overrides: Record<string, any> = {}) {
  return {
    id: 1,
    roomId: 1,
    sessionId: 1,
    description: 'Water staining on ceiling drywall',
    damageType: 'water_damage',
    severity: 'moderate',
    location: 'ceiling',
    createdAt: new Date(),
    ...overrides,
  };
}

/**
 * Mock photo
 */
export function makePhoto(overrides: Record<string, any> = {}) {
  return {
    id: 1,
    sessionId: 1,
    roomId: 1,
    caption: 'Water damage on ceiling',
    photoType: 'damage_detail',
    storagePath: '/photos/1.jpg',
    analysis: { description: 'Visible water staining on drywall ceiling' },
    autoTag: 'water_damage',
    createdAt: new Date(),
    ...overrides,
  };
}

/**
 * Mock moisture reading
 */
export function makeMoistureReading(overrides: Record<string, any> = {}) {
  return {
    id: 1,
    roomId: 1,
    sessionId: 1,
    location: 'North wall, 2ft from floor',
    materialType: 'drywall',
    reading: 28.5,
    dryStandard: 15,
    isElevated: true,
    createdAt: new Date(),
    ...overrides,
  };
}

STEP 7: Estimate Engine Tests — test/estimateEngine.test.ts
This is the highest-value test file — estimateEngine.ts contains the core pricing math that drives every dollar figure in the app.
IMPORTANT: calculateLineItemPrice and calculateEstimateTotals are synchronous pure functions — they don't touch the database. They can be tested directly without mocking. However, lookupCatalogItem and getRegionalPrice DO hit the database via import { db } from "./db". You need to mock the db module at the top of the test file.
typescriptimport { describe, it, expect, vi, beforeEach } from 'vitest';
import {
  calculateLineItemPrice,
  calculateEstimateTotals,
  validateEstimate,
  getCompanionSuggestions,
  TRADE_CODES,
  type PricedLineItem,
} from '../server/estimateEngine';
import { makeCatalogItem, makeRegionalPrice, makePricedItem } from './mocks/fixtures';

// Mock the db module so lookupCatalogItem / getRegionalPrice don't need a real DB
vi.mock('../server/db', () => ({
  db: {
    select: vi.fn().mockReturnValue({
      from: vi.fn().mockReturnValue({
        where: vi.fn().mockReturnValue({
          limit: vi.fn().mockResolvedValue([]),
        }),
      }),
    }),
  },
}));

// ─────────────────────────────────────────────────
// TRADE_CODES
// ─────────────────────────────────────────────────
describe('TRADE_CODES', () => {
  it('contains at least 14 base trades', () => {
    expect(TRADE_CODES.length).toBeGreaterThanOrEqual(14);
  });

  it('includes all core trade codes', () => {
    const required = ['MIT', 'DEM', 'DRY', 'PNT', 'FLR', 'INS', 'CAR', 'CAB', 'CTR', 'RFG', 'WIN', 'EXT', 'ELE', 'PLM'];
    for (const code of required) {
      expect(TRADE_CODES).toContain(code);
    }
  });

  // After PROMPT-10 is applied:
  it('includes HVAC and GEN trades (post-PROMPT-10)', () => {
    // If PROMPT-10 hasn't been applied yet, these will fail — that's correct
    expect(TRADE_CODES).toContain('HVAC');
    expect(TRADE_CODES).toContain('GEN');
    expect(TRADE_CODES.length).toBe(16);
  });
});

// ─────────────────────────────────────────────────
// calculateLineItemPrice
// ─────────────────────────────────────────────────
describe('calculateLineItemPrice', () => {
  const catalog = makeCatalogItem({ code: 'DRY-12-SF', tradeCode: 'DRY', defaultWasteFactor: 10 });
  const price = makeRegionalPrice({ materialCost: 0.52, laborCost: 0.92, equipmentCost: 0.06 });

  it('calculates unit price = (M + L + E) × (1 + waste%/100)', () => {
    const result = calculateLineItemPrice(catalog, price, 100);
    // Base = 0.52 + 0.92 + 0.06 = 1.50
    // With 10% waste = 1.50 × 1.10 = 1.65
    expect(result.unitPriceBreakdown.unitPrice).toBeCloseTo(1.65, 2);
  });

  it('calculates total price = unitPrice × quantity', () => {
    const result = calculateLineItemPrice(catalog, price, 200);
    expect(result.totalPrice).toBeCloseTo(1.65 * 200, 2);
  });

  it('applies waste factor to each cost component individually', () => {
    const result = calculateLineItemPrice(catalog, price, 1);
    expect(result.unitPriceBreakdown.materialCost).toBeCloseTo(0.52 * 1.10, 4);
    expect(result.unitPriceBreakdown.laborCost).toBeCloseTo(0.92 * 1.10, 4);
    expect(result.unitPriceBreakdown.equipmentCost).toBeCloseTo(0.06 * 1.10, 4);
  });

  it('uses 0 waste when catalog item has no defaultWasteFactor', () => {
    const noWaste = makeCatalogItem({ defaultWasteFactor: 0 });
    const result = calculateLineItemPrice(noWaste, price, 100);
    expect(result.unitPriceBreakdown.wasteFactor).toBe(0);
    expect(result.unitPriceBreakdown.unitPrice).toBeCloseTo(1.50, 2);
  });

  it('allows overriding the waste factor', () => {
    const result = calculateLineItemPrice(catalog, price, 100, 15);
    // 15% waste: 1.50 × 1.15 = 1.725
    expect(result.unitPriceBreakdown.wasteFactor).toBe(15);
    expect(result.unitPriceBreakdown.unitPrice).toBeCloseTo(1.725, 3);
  });

  it('returns correct code, description, unit, tradeCode from catalog', () => {
    const result = calculateLineItemPrice(catalog, price, 50);
    expect(result.code).toBe('DRY-12-SF');
    expect(result.unit).toBe('SF');
    expect(result.tradeCode).toBe('DRY');
  });

  it('handles zero quantity gracefully', () => {
    const result = calculateLineItemPrice(catalog, price, 0);
    expect(result.totalPrice).toBe(0);
    expect(result.quantity).toBe(0);
  });

  it('handles null/missing regional price fields', () => {
    const emptyPrice = { materialCost: null, laborCost: null, equipmentCost: null };
    const result = calculateLineItemPrice(catalog, emptyPrice, 100);
    expect(result.totalPrice).toBe(0);
  });
});

// ─────────────────────────────────────────────────
// calculateEstimateTotals
// ─────────────────────────────────────────────────
describe('calculateEstimateTotals', () => {
  it('sums material, labor, equipment across all items', () => {
    const items: PricedLineItem[] = [
      makePricedItem({ tradeCode: 'DRY', quantity: 100 }),
      makePricedItem({ tradeCode: 'PNT', quantity: 200, code: 'PNT-WALL-SF' }),
    ];
    const totals = calculateEstimateTotals(items);
    expect(totals.subtotalMaterial).toBeGreaterThan(0);
    expect(totals.subtotalLabor).toBeGreaterThan(0);
    expect(totals.subtotal).toBe(totals.subtotalMaterial + totals.subtotalLabor + totals.subtotalEquipment);
  });

  it('calculates tax at the provided rate', () => {
    const items: PricedLineItem[] = [makePricedItem({ tradeCode: 'DRY' })];
    const totals = calculateEstimateTotals(items, 0.10);
    expect(totals.taxAmount).toBeCloseTo(totals.subtotal * 0.10, 2);
  });

  it('defaults to 8% tax when not specified', () => {
    const items: PricedLineItem[] = [makePricedItem({ tradeCode: 'DRY' })];
    const totals = calculateEstimateTotals(items);
    expect(totals.taxAmount).toBeCloseTo(totals.subtotal * 0.08, 2);
  });

  describe('O&P (Overhead & Profit) threshold', () => {
    it('does NOT qualify for O&P with fewer than 3 trades', () => {
      const items: PricedLineItem[] = [
        makePricedItem({ tradeCode: 'DRY' }),
        makePricedItem({ tradeCode: 'PNT', code: 'PNT-WALL-SF' }),
      ];
      const totals = calculateEstimateTotals(items);
      expect(totals.qualifiesForOP).toBe(false);
      expect(totals.overheadAmount).toBe(0);
      expect(totals.profitAmount).toBe(0);
    });

    it('qualifies for O&P with exactly 3 trades', () => {
      const items: PricedLineItem[] = [
        makePricedItem({ tradeCode: 'DRY' }),
        makePricedItem({ tradeCode: 'PNT', code: 'PNT-WALL-SF' }),
        makePricedItem({ tradeCode: 'FLR', code: 'FLR-CAR-SF' }),
      ];
      const totals = calculateEstimateTotals(items);
      expect(totals.qualifiesForOP).toBe(true);
      expect(totals.overheadAmount).toBeCloseTo(totals.subtotal * 0.10, 2);
      expect(totals.profitAmount).toBeCloseTo(totals.subtotal * 0.10, 2);
    });

    it('includes O&P in totalWithOP', () => {
      const items: PricedLineItem[] = [
        makePricedItem({ tradeCode: 'DRY' }),
        makePricedItem({ tradeCode: 'PNT', code: 'PNT-WALL-SF' }),
        makePricedItem({ tradeCode: 'FLR', code: 'FLR-CAR-SF' }),
      ];
      const totals = calculateEstimateTotals(items);
      expect(totals.totalWithOP).toBeCloseTo(
        totals.subtotal + totals.taxAmount + totals.overheadAmount + totals.profitAmount,
        2,
      );
    });

    it('does NOT count duplicate trade codes as separate trades', () => {
      const items: PricedLineItem[] = [
        makePricedItem({ tradeCode: 'DRY', code: 'DRY-12-SF' }),
        makePricedItem({ tradeCode: 'DRY', code: 'DRY-58-SF' }),
        makePricedItem({ tradeCode: 'PNT', code: 'PNT-WALL-SF' }),
      ];
      const totals = calculateEstimateTotals(items);
      // Only 2 unique trades: DRY, PNT → no O&P
      expect(totals.qualifiesForOP).toBe(false);
      expect(totals.tradesInvolved).toHaveLength(2);
    });
  });

  // Post-PROMPT-10: overhead/profit override parameters
  describe('O&P override parameters (post-PROMPT-10)', () => {
    it('uses custom overhead percentage when provided', () => {
      const items: PricedLineItem[] = [
        makePricedItem({ tradeCode: 'DRY' }),
        makePricedItem({ tradeCode: 'PNT', code: 'PNT-WALL-SF' }),
        makePricedItem({ tradeCode: 'FLR', code: 'FLR-CAR-SF' }),
      ];
      // After PROMPT-10, signature becomes: calculateEstimateTotals(items, taxRate, overheadPct?, profitPct?)
      const totals = calculateEstimateTotals(items, 0.08, 0.15, 0.12);
      expect(totals.overheadAmount).toBeCloseTo(totals.subtotal * 0.15, 2);
      expect(totals.profitAmount).toBeCloseTo(totals.subtotal * 0.12, 2);
    });
  });

  it('returns empty results for an empty items array', () => {
    const totals = calculateEstimateTotals([]);
    expect(totals.subtotal).toBe(0);
    expect(totals.grandTotal).toBe(0);
    expect(totals.tradesInvolved).toHaveLength(0);
    expect(totals.qualifiesForOP).toBe(false);
  });
});

// ─────────────────────────────────────────────────
// validateEstimate
// ─────────────────────────────────────────────────
describe('validateEstimate', () => {
  it('returns valid when items have no issues', async () => {
    const items: PricedLineItem[] = [
      makePricedItem({ code: 'DRY-12-SF', tradeCode: 'DRY', quantity: 100 }),
    ];
    const result = await validateEstimate(items);
    expect(result.valid).toBe(true);
    expect(result.errors).toHaveLength(0);
  });

  it('warns about duplicate item codes', async () => {
    const items: PricedLineItem[] = [
      makePricedItem({ code: 'DRY-12-SF' }),
      makePricedItem({ code: 'DRY-12-SF' }),
    ];
    const result = await validateEstimate(items);
    expect(result.warnings.some((w) => w.includes('Duplicate'))).toBe(true);
  });

  it('warns when DRY present without DEM', async () => {
    const items: PricedLineItem[] = [
      makePricedItem({ code: 'DRY-12-SF', tradeCode: 'DRY' }),
    ];
    const result = await validateEstimate(items);
    expect(result.warnings.some((w) => w.includes('Demolition'))).toBe(true);
  });

  it('warns when PNT present without DRY', async () => {
    const items: PricedLineItem[] = [
      makePricedItem({ code: 'PNT-WALL-SF', tradeCode: 'PNT' }),
    ];
    const result = await validateEstimate(items);
    expect(result.warnings.some((w) => w.includes('Drywall'))).toBe(true);
  });

  it('errors on items with zero quantity', async () => {
    const items: PricedLineItem[] = [
      makePricedItem({ code: 'DRY-12-SF', tradeCode: 'DRY', quantity: 0 }),
    ];
    const result = await validateEstimate(items);
    expect(result.valid).toBe(false);
    expect(result.errors.some((e) => e.includes('invalid quantity'))).toBe(true);
  });

  it('errors on items with negative quantity', async () => {
    const items: PricedLineItem[] = [
      makePricedItem({ code: 'DRY-12-SF', tradeCode: 'DRY', quantity: -5 }),
    ];
    const result = await validateEstimate(items);
    expect(result.valid).toBe(false);
  });
});

// ─────────────────────────────────────────────────
// getCompanionSuggestions
// ─────────────────────────────────────────────────
describe('getCompanionSuggestions', () => {
  it('suggests underlayment when roofing is present (pre-PROMPT-10)', async () => {
    const items: PricedLineItem[] = [
      makePricedItem({ code: 'RFG-SHIN-SQ', tradeCode: 'RFG' }),
    ];
    const suggestions = await getCompanionSuggestions(items);
    // Pre-PROMPT-10: suggests RFG-UNDER-SF (wrong code)
    // Post-PROMPT-10: suggests RFG-FELT-SQ, RFG-ICE-SQ, RFG-DRIP-LF, RFG-RIDG-LF
    expect(suggestions.length).toBeGreaterThan(0);
  });

  it('suggests tape/compound when drywall is present', async () => {
    const items: PricedLineItem[] = [
      makePricedItem({ code: 'DRY-12-SF', tradeCode: 'DRY' }),
    ];
    const suggestions = await getCompanionSuggestions(items);
    expect(suggestions.length).toBeGreaterThan(0);
  });

  it('suggests underlayment when flooring is present', async () => {
    const items: PricedLineItem[] = [
      makePricedItem({ code: 'FLR-CAR-SF', tradeCode: 'FLR' }),
    ];
    const suggestions = await getCompanionSuggestions(items);
    expect(suggestions.length).toBeGreaterThan(0);
  });

  it('returns no suggestions when nothing triggers companions', async () => {
    const items: PricedLineItem[] = [
      makePricedItem({ code: 'ELE-OUTLET-EA', tradeCode: 'ELE' }),
    ];
    const suggestions = await getCompanionSuggestions(items);
    expect(suggestions).toHaveLength(0);
  });

  it('does not suggest items that already exist in the estimate', async () => {
    const items: PricedLineItem[] = [
      makePricedItem({ code: 'DRY-12-SF', tradeCode: 'DRY' }),
      makePricedItem({ code: 'DRY-TAPE-LF', tradeCode: 'DRY' }), // Pre-PROMPT-10 companion code
    ];
    const suggestions = await getCompanionSuggestions(items);
    // Should not re-suggest DRY-TAPE-LF since it's already present
    const suggestionTexts = suggestions.join(' ');
    expect(suggestionTexts).not.toContain('DRY-TAPE-LF');
  });
});

// ─────────────────────────────────────────────────
// Post-PROMPT-10 companion suggestions (corrected codes)
// ─────────────────────────────────────────────────
describe('getCompanionSuggestions (post-PROMPT-10 corrected codes)', () => {
  // After PROMPT-10, getCompanionSuggestions returns Array<{code, reason}> instead of string[]
  // These tests validate the corrected companion codes reference real catalog items.

  it('suggests RFG-FELT-SQ (not RFG-UNDER-SF) for roofing', async () => {
    const items: PricedLineItem[] = [
      makePricedItem({ code: 'RFG-SHIN-SQ', tradeCode: 'RFG' }),
    ];
    const result = await getCompanionSuggestions(items);
    // Post-PROMPT-10: result is Array<{code, reason}>
    // Pre-PROMPT-10: result is string[]
    const codes = Array.isArray(result) && typeof result[0] === 'object'
      ? result.map((r: any) => r.code)
      : result;
    expect(codes).toContain('RFG-FELT-SQ');
    expect(codes).not.toContain('RFG-UNDER-SF');
  });

  it('suggests DRY-TAPE-SF and DRY-TEXT-SF for drywall', async () => {
    const items: PricedLineItem[] = [
      makePricedItem({ code: 'DRY-12-SF', tradeCode: 'DRY' }),
    ];
    const result = await getCompanionSuggestions(items);
    const codes = Array.isArray(result) && typeof result[0] === 'object'
      ? result.map((r: any) => r.code)
      : result;
    expect(codes).toContain('DRY-TAPE-SF');
    expect(codes).toContain('DRY-TEXT-SF');
  });

  it('suggests FLR-ULAY-SF (not FLR-PAD-SF) for generic flooring', async () => {
    const items: PricedLineItem[] = [
      makePricedItem({ code: 'FLR-VIN-SF', tradeCode: 'FLR' }),
    ];
    const result = await getCompanionSuggestions(items);
    const codes = Array.isArray(result) && typeof result[0] === 'object'
      ? result.map((r: any) => r.code)
      : result;
    expect(codes).toContain('FLR-ULAY-SF');
  });

  it('suggests GEN-PROT-SF when 3+ trades present', async () => {
    const items: PricedLineItem[] = [
      makePricedItem({ code: 'DRY-12-SF', tradeCode: 'DRY' }),
      makePricedItem({ code: 'PNT-WALL-SF', tradeCode: 'PNT' }),
      makePricedItem({ code: 'FLR-CAR-SF', tradeCode: 'FLR' }),
    ];
    const result = await getCompanionSuggestions(items);
    const codes = Array.isArray(result) && typeof result[0] === 'object'
      ? result.map((r: any) => r.code)
      : result;
    expect(codes).toContain('GEN-PROT-SF');
  });
});

STEP 8: ESX Generator Tests — test/esxGenerator.test.ts
Tests that the ESX generator produces a valid ZIP containing the expected XML documents.
typescriptimport { describe, it, expect, vi, beforeEach } from 'vitest';
import { generateESXFile } from '../server/esxGenerator';
import { createMockStorage } from './mocks/storage.mock';
import { makeClaim, makeSession, makeRoom, makeLineItem } from './mocks/fixtures';
import { Readable } from 'stream';

describe('generateESXFile', () => {
  const claim = makeClaim();
  const session = makeSession();
  const rooms = [
    makeRoom({ id: 1, name: 'Kitchen' }),
    makeRoom({ id: 2, name: 'Living Room' }),
  ];
  const lineItems = [
    makeLineItem({ id: 1, roomId: 1, category: 'Drywall', xactCode: 'DRY-12-SF' }),
    makeLineItem({ id: 2, roomId: 1, category: 'Painting', xactCode: 'PNT-WALL-SF' }),
    makeLineItem({ id: 3, roomId: 2, category: 'Flooring', xactCode: 'FLR-CAR-SF' }),
  ];
  const summary = { totalRCV: 495.0, totalDepreciation: 49.5, totalACV: 445.5, itemCount: 3 };

  function createTestStorage() {
    return createMockStorage({
      getInspectionSession: vi.fn().mockResolvedValue(session),
      getClaim: vi.fn().mockResolvedValue(claim),
      getRooms: vi.fn().mockResolvedValue(rooms),
      getLineItems: vi.fn().mockResolvedValue(lineItems),
      getEstimateSummary: vi.fn().mockResolvedValue(summary),
    });
  }

  it('returns a Buffer', async () => {
    const storage = createTestStorage();
    const result = await generateESXFile(1, storage);
    expect(Buffer.isBuffer(result)).toBe(true);
    expect(result.length).toBeGreaterThan(0);
  });

  it('produces a valid ZIP (starts with PK magic bytes)', async () => {
    const storage = createTestStorage();
    const result = await generateESXFile(1, storage);
    // ZIP files start with PK (0x50 0x4B)
    expect(result[0]).toBe(0x50);
    expect(result[1]).toBe(0x4B);
  });

  it('calls the correct storage methods', async () => {
    const storage = createTestStorage();
    await generateESXFile(1, storage);

    expect(storage.getInspectionSession).toHaveBeenCalledWith(1);
    expect(storage.getClaim).toHaveBeenCalledWith(claim.id);
    expect(storage.getRooms).toHaveBeenCalledWith(1);
    expect(storage.getLineItems).toHaveBeenCalledWith(1);
    expect(storage.getEstimateSummary).toHaveBeenCalledWith(1);
  });

  it('throws if session not found', async () => {
    const storage = createMockStorage({
      getInspectionSession: vi.fn().mockResolvedValue(undefined),
    });
    await expect(generateESXFile(999, storage)).rejects.toThrow('Session not found');
  });

  it('throws if claim not found', async () => {
    const storage = createMockStorage({
      getInspectionSession: vi.fn().mockResolvedValue(session),
      getClaim: vi.fn().mockResolvedValue(undefined),
    });
    await expect(generateESXFile(1, storage)).rejects.toThrow('Claim not found');
  });

  // XML content validation — extract the ZIP and inspect the XML strings
  // Since we can't easily unzip in a test without adding a dep, we validate
  // by checking the buffer contains expected XML strings
  it('contains XACTDOC.XML marker in the ZIP', async () => {
    const storage = createTestStorage();
    const result = await generateESXFile(1, storage);
    const bufStr = result.toString('utf-8');
    expect(bufStr).toContain('XACTDOC.XML');
  });

  it('contains GENERIC_ROUGHDRAFT.XML marker in the ZIP', async () => {
    const storage = createTestStorage();
    const result = await generateESXFile(1, storage);
    const bufStr = result.toString('utf-8');
    expect(bufStr).toContain('GENERIC_ROUGHDRAFT.XML');
  });

  it('embeds the claim number in the XML', async () => {
    const storage = createTestStorage();
    const result = await generateESXFile(1, storage);
    const bufStr = result.toString('utf-8');
    expect(bufStr).toContain('CLM-2025-001');
  });

  it('embeds room names in the rough draft XML', async () => {
    const storage = createTestStorage();
    const result = await generateESXFile(1, storage);
    const bufStr = result.toString('utf-8');
    expect(bufStr).toContain('Kitchen');
    expect(bufStr).toContain('Living Room');
  });

  it('groups line items by room', async () => {
    const storage = createTestStorage();
    const result = await generateESXFile(1, storage);
    const bufStr = result.toString('utf-8');
    // Kitchen should have items before Living Room
    const kitchenPos = bufStr.indexOf('Kitchen');
    const livingPos = bufStr.indexOf('Living Room');
    expect(kitchenPos).toBeGreaterThan(-1);
    expect(livingPos).toBeGreaterThan(-1);
  });

  it('handles session with zero line items', async () => {
    const storage = createMockStorage({
      getInspectionSession: vi.fn().mockResolvedValue(session),
      getClaim: vi.fn().mockResolvedValue(claim),
      getRooms: vi.fn().mockResolvedValue(rooms),
      getLineItems: vi.fn().mockResolvedValue([]),
      getEstimateSummary: vi.fn().mockResolvedValue({ totalRCV: 0, totalDepreciation: 0, totalACV: 0, itemCount: 0 }),
    });
    const result = await generateESXFile(1, storage);
    expect(Buffer.isBuffer(result)).toBe(true);
  });

  it('escapes XML special characters in claim data', async () => {
    const xssClaim = makeClaim({ insuredName: 'O\'Brien & Associates <LLC>' });
    const storage = createMockStorage({
      getInspectionSession: vi.fn().mockResolvedValue(session),
      getClaim: vi.fn().mockResolvedValue(xssClaim),
      getRooms: vi.fn().mockResolvedValue(rooms),
      getLineItems: vi.fn().mockResolvedValue(lineItems),
      getEstimateSummary: vi.fn().mockResolvedValue(summary),
    });
    const result = await generateESXFile(1, storage);
    const bufStr = result.toString('utf-8');
    // Should have escaped & < > ' characters
    expect(bufStr).toContain('&amp;');
    expect(bufStr).toContain('&lt;');
  });
});

STEP 9: PDF Generator Tests — test/pdfGenerator.test.ts
The PDF generator uses pdfkit to produce binary buffers. Tests verify the output is a valid PDF and that data flows through correctly.
typescriptimport { describe, it, expect } from 'vitest';
import { generateInspectionPDF } from '../server/pdfGenerator';
import {
  makeClaim,
  makeSession,
  makeRoom,
  makeDamage,
  makeLineItem,
  makePhoto,
  makeMoistureReading,
} from './mocks/fixtures';

function makeMinimalPDFData() {
  return {
    claim: makeClaim(),
    session: makeSession(),
    rooms: [makeRoom()],
    damages: [makeDamage()],
    lineItems: [makeLineItem()],
    photos: [],
    moistureReadings: [],
    estimate: {
      totalRCV: 165.0,
      totalDepreciation: 16.5,
      totalACV: 148.5,
      itemCount: 1,
      categories: [
        {
          category: 'Drywall',
          subtotal: 165.0,
          items: [makeLineItem()],
        },
      ],
    },
    inspectorName: 'Test Inspector',
  };
}

describe('generateInspectionPDF', () => {
  it('returns a Buffer', async () => {
    const result = await generateInspectionPDF(makeMinimalPDFData());
    expect(Buffer.isBuffer(result)).toBe(true);
  });

  it('produces a valid PDF (starts with %PDF magic bytes)', async () => {
    const result = await generateInspectionPDF(makeMinimalPDFData());
    const header = result.slice(0, 5).toString('ascii');
    expect(header).toBe('%PDF-');
  });

  it('produces a non-trivial PDF (at least 1KB)', async () => {
    const result = await generateInspectionPDF(makeMinimalPDFData());
    expect(result.length).toBeGreaterThan(1024);
  });

  it('handles empty rooms array', async () => {
    const data = makeMinimalPDFData();
    data.rooms = [];
    data.damages = [];
    data.lineItems = [];
    data.estimate.categories = [];
    const result = await generateInspectionPDF(data);
    expect(Buffer.isBuffer(result)).toBe(true);
  });

  it('handles null claim gracefully', async () => {
    const data = makeMinimalPDFData();
    data.claim = null;
    const result = await generateInspectionPDF(data);
    expect(Buffer.isBuffer(result)).toBe(true);
  });

  it('includes photo appendix when photos are present', async () => {
    const data = makeMinimalPDFData();
    data.photos = [makePhoto(), makePhoto({ id: 2, caption: 'Second photo' })];
    const result = await generateInspectionPDF(data);
    // A PDF with photos should be larger than one without
    const noPhotosResult = await generateInspectionPDF(makeMinimalPDFData());
    expect(result.length).toBeGreaterThan(noPhotosResult.length);
  });

  it('includes moisture report for water peril claims with readings', async () => {
    const data = makeMinimalPDFData();
    data.claim = makeClaim({ perilType: 'water' });
    data.moistureReadings = [
      makeMoistureReading(),
      makeMoistureReading({ id: 2, location: 'South wall', reading: 32.1 }),
    ];
    const result = await generateInspectionPDF(data);
    // Should be larger than a PDF without moisture data
    const noMoistureResult = await generateInspectionPDF(makeMinimalPDFData());
    expect(result.length).toBeGreaterThan(noMoistureResult.length);
  });

  it('skips moisture report for non-water perils', async () => {
    const data = makeMinimalPDFData();
    data.claim = makeClaim({ perilType: 'fire' });
    data.moistureReadings = [makeMoistureReading()];
    const resultFire = await generateInspectionPDF(data);

    data.claim = makeClaim({ perilType: 'water' });
    const resultWater = await generateInspectionPDF(data);

    // Water peril with readings should produce more pages/content
    expect(resultWater.length).toBeGreaterThan(resultFire.length);
  });

  it('handles large number of rooms without error', async () => {
    const data = makeMinimalPDFData();
    data.rooms = Array.from({ length: 20 }, (_, i) =>
      makeRoom({ id: i + 1, name: `Room ${i + 1}` }),
    );
    data.damages = data.rooms.map((r) => makeDamage({ roomId: r.id }));
    data.lineItems = data.rooms.map((r) => makeLineItem({ roomId: r.id }));
    const result = await generateInspectionPDF(data);
    expect(Buffer.isBuffer(result)).toBe(true);
  });

  it('uses default inspector name when not provided', async () => {
    const data = makeMinimalPDFData();
    delete (data as any).inspectorName;
    const result = await generateInspectionPDF(data);
    expect(Buffer.isBuffer(result)).toBe(true);
  });
});

STEP 10: Module Mock for Database Import
The estimateEngine.ts file imports from ./db which tries to connect to PostgreSQL. Create a mock module to prevent that:
Create server/__mocks__/db.ts:
typescriptimport { vi } from 'vitest';

export const db = {
  select: vi.fn().mockReturnValue({
    from: vi.fn().mockReturnValue({
      where: vi.fn().mockReturnValue({
        limit: vi.fn().mockResolvedValue([]),
      }),
    }),
  }),
};
Then add to vitest.config.ts if needed (Vitest automatically picks up __mocks__ directories in the same folder as the mocked module when vi.mock() is used).

Running the Tests
After all files are created:
bash# Run all tests
npm test

# Run in watch mode during development
npm run test:watch

# Run with coverage report
npm run test:coverage

# Run a specific test file
npx vitest run test/estimateEngine.test.ts
Expected Results
After PROMPT-10 is applied:

estimateEngine.test.ts: All tests pass (including HVAC/GEN trade codes and corrected companion codes)
esxGenerator.test.ts: All tests pass
pdfGenerator.test.ts: All tests pass

Before PROMPT-10 is applied:

TRADE_CODES HVAC/GEN test will fail ✓ (expected — validates PROMPT-10 is needed)
O&P override test will fail ✓ (expected — calculateEstimateTotals doesn't accept overrides yet)
Corrected companion code tests will fail ✓ (expected — codes haven't been fixed yet)
All other tests should pass ✓


Test Coverage Targets
ModuleTargetKey AreasestimateEngine.ts90%+All pure functions fully covered; only DB-hitting functions (lookupCatalogItem, getRegionalPrice) excluded by mockesxGenerator.ts80%+Core generation path covered; edge cases for empty data coveredpdfGenerator.ts70%+Buffer generation covered; internal render functions indirectly tested via output size differences

File Checklist
FileActionPurposepackage.jsonAdd 2 devDeps + 3 scriptsvitest, @vitest/coverage-v8vitest.config.tsCREATETest runner config with path aliasesserver/__mocks__/db.tsCREATEMock database moduletest/mocks/storage.mock.tsCREATEIStorage mock factorytest/mocks/fixtures.tsCREATEReusable test data builderstest/estimateEngine.test.tsCREATE25+ tests for pricing mathtest/esxGenerator.test.tsCREATE10+ tests for XML/ZIP generationtest/pdfGenerator.test.tsCREATE10+ tests for PDF generation
Total: 8 files to create/modify, ~45+ test cases.

Summary
This prompt adds a full test infrastructure to Claims IQ with zero runtime dependencies — tests run against mocked storage, never touching a database. The test suite serves as both a regression safety net and a living specification of the pricing engine's business rules (O&P threshold, waste factor math, companion code logic). Apply PROMPT-10 first, then run npm test — all 45+ tests should pass green.