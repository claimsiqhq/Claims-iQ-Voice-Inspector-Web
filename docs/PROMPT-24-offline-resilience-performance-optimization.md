# PROMPT-24 — Offline Resilience, Code Splitting & Performance Optimization

## Context

The application targets field insurance adjusters who frequently work at damaged properties with unreliable connectivity. The current state:

- **Offline support**: Workbox service worker auto-generated by `vite-plugin-pwa` in `vite.config.ts` (lines 15–79) handles asset caching and API response caching (NetworkFirst, 5-minute expiry). But there is no offline mutation queue — if a request fails while offline, it's simply lost.
- **Code splitting**: None. All 13 page components are imported synchronously in `App.tsx`. No `React.lazy()`, no `<Suspense>` boundaries, no dynamic imports.
- **Error boundaries**: A single class-based `ErrorBoundary` exists in `App.tsx` (lines 25–68) wrapping the entire app. No granular boundaries around individual routes or heavy components.
- **Mutations**: 39 `useMutation` calls across the client. ActiveInspection.tsx alone has mutations for session start, room creation, damage recording, line items, and photo capture — all critical operations that must survive connectivity drops.
- **Toast system**: Fully implemented via `use-toast.ts` hook (192 lines) + Radix UI toast primitives + Sonner integration. Ready for offline status notifications.

This prompt adds offline mutation queuing, code splitting, enhanced error recovery, and an online/offline awareness layer.

**Depends on**: PROMPT-23 (session persistence), all prior prompts

---

## Part A — Code Splitting with React.lazy

### A.1 — Convert Page Imports to Lazy Loads

In `client/src/App.tsx`, replace the synchronous page imports with `React.lazy`:

```tsx
// REPLACE all page imports (near top of App.tsx) with:
import { lazy, Suspense } from "react";

// Keep these synchronous (lightweight, always needed):
import NotFound from "@/pages/not-found";
// ErrorBoundary stays inline in this file (or extracted per Part A.3)

// Lazy-load all page components:
const ClaimsList = lazy(() => import("@/pages/ClaimsList"));
const ActiveInspection = lazy(() => import("@/pages/ActiveInspection"));
const ReviewFinalize = lazy(() => import("@/pages/ReviewFinalize"));
const ExportPage = lazy(() => import("@/pages/ExportPage"));
const DocumentsHub = lazy(() => import("@/pages/DocumentsHub"));
const DocumentUpload = lazy(() => import("@/pages/DocumentUpload"));
const ExtractionReview = lazy(() => import("@/pages/ExtractionReview"));
const InspectionBriefing = lazy(() => import("@/pages/InspectionBriefing"));
const SupervisorDashboard = lazy(() => import("@/pages/SupervisorDashboard"));
const SettingsPage = lazy(() => import("@/pages/SettingsPage"));
const LoginPage = lazy(() => import("@/pages/LoginPage"));
const SupplementalPage = lazy(() => import("@/pages/SupplementalPage"));
```

**Note**: Each page component must have a `default` export for `React.lazy` to work. Verify each page file uses `export default function PageName()` or `export default PageName`.

### A.2 — Add Suspense Boundaries

Wrap the route switch in a `<Suspense>` boundary with a loading fallback:

```tsx
// In the Router component, wrap routes with Suspense:
function Router() {
  return (
    <Suspense fallback={<PageLoadingFallback />}>
      <Switch>
        {/* ... existing routes ... */}
      </Switch>
    </Suspense>
  );
}

// ADD a lightweight loading fallback component (above Router):
function PageLoadingFallback() {
  return (
    <div className="flex items-center justify-center min-h-screen">
      <div className="text-center">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-4" />
        <p className="text-sm text-gray-500">Loading...</p>
      </div>
    </div>
  );
}
```

### A.3 — Route-Level Error Boundaries

Extract the inline `ErrorBoundary` from `App.tsx` into its own component and add route-level granularity:

Create `client/src/components/ErrorBoundary.tsx`:

```tsx
import { Component, type ReactNode } from "react";

interface ErrorBoundaryProps {
  children: ReactNode;
  fallback?: ReactNode;
  onError?: (error: Error, errorInfo: React.ErrorInfo) => void;
  /** If true, shows a smaller inline error instead of full-page */
  inline?: boolean;
}

interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
}

export class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error) {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error("ErrorBoundary caught:", error, errorInfo);
    this.props.onError?.(error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      if (this.props.fallback) return this.props.fallback;

      if (this.props.inline) {
        return (
          <div className="bg-red-50 border border-red-200 rounded-md p-4 m-4">
            <h3 className="text-sm font-medium text-red-800">Something went wrong</h3>
            <p className="text-sm text-red-600 mt-1">{this.state.error?.message}</p>
            <button
              className="mt-2 text-sm text-red-700 underline hover:text-red-900"
              onClick={() => this.setState({ hasError: false, error: null })}
            >
              Try again
            </button>
          </div>
        );
      }

      return (
        <div className="flex items-center justify-center min-h-screen bg-gray-50">
          <div className="text-center p-8 max-w-md">
            <h1 className="text-2xl font-bold text-gray-900 mb-2">Something went wrong</h1>
            <p className="text-gray-600 mb-4">
              {this.state.error?.message || "An unexpected error occurred."}
            </p>
            <div className="space-x-3">
              <button
                className="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700"
                onClick={() => this.setState({ hasError: false, error: null })}
              >
                Try Again
              </button>
              <button
                className="bg-gray-200 text-gray-700 px-4 py-2 rounded-md hover:bg-gray-300"
                onClick={() => window.location.reload()}
              >
                Reload Page
              </button>
            </div>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}
```

Then wrap critical routes with their own error boundaries in `App.tsx`:

```tsx
import { ErrorBoundary } from "@/components/ErrorBoundary";

// In the Router, wrap heavy/critical routes:
<Route path="/inspection/:claimId/active">
  <ErrorBoundary>
    <ActiveInspection />
  </ErrorBoundary>
</Route>

<Route path="/inspection/:claimId/export">
  <ErrorBoundary>
    <ExportPage />
  </ErrorBoundary>
</Route>

<Route path="/supervisor">
  <ErrorBoundary>
    <SupervisorDashboard />
  </ErrorBoundary>
</Route>
```

---

## Part B — Online/Offline Awareness

### B.1 — Create Online Status Hook

Create `client/src/hooks/useOnlineStatus.ts`:

```ts
import { useState, useEffect, useCallback } from "react";

interface OnlineStatus {
  isOnline: boolean;
  /** Timestamp of last connectivity change */
  lastChanged: number;
  /** Number of pending offline mutations */
  pendingMutations: number;
  /** Force a connectivity check by pinging the health endpoint */
  checkConnectivity: () => Promise<boolean>;
}

export function useOnlineStatus(): OnlineStatus {
  const [isOnline, setIsOnline] = useState(navigator.onLine);
  const [lastChanged, setLastChanged] = useState(Date.now());
  const [pendingMutations, setPendingMutations] = useState(0);

  useEffect(() => {
    const handleOnline = () => {
      setIsOnline(true);
      setLastChanged(Date.now());
    };
    const handleOffline = () => {
      setIsOnline(false);
      setLastChanged(Date.now());
    };

    window.addEventListener("online", handleOnline);
    window.addEventListener("offline", handleOffline);

    return () => {
      window.removeEventListener("online", handleOnline);
      window.removeEventListener("offline", handleOffline);
    };
  }, []);

  // Listen for mutation queue changes
  useEffect(() => {
    const updatePending = () => {
      const count = parseInt(
        localStorage.getItem("offline-queue-count") || "0",
        10
      );
      setPendingMutations(count);
    };

    updatePending();
    window.addEventListener("storage", updatePending);
    // Custom event for same-tab updates
    window.addEventListener("offline-queue-changed", updatePending);

    return () => {
      window.removeEventListener("storage", updatePending);
      window.removeEventListener("offline-queue-changed", updatePending);
    };
  }, []);

  const checkConnectivity = useCallback(async (): Promise<boolean> => {
    try {
      const response = await fetch("/health", {
        method: "GET",
        cache: "no-store",
        signal: AbortSignal.timeout(5000),
      });
      const online = response.ok;
      setIsOnline(online);
      return online;
    } catch {
      setIsOnline(false);
      return false;
    }
  }, []);

  return { isOnline, lastChanged, pendingMutations, checkConnectivity };
}
```

### B.2 — Offline Status Banner

Create `client/src/components/OfflineBanner.tsx`:

```tsx
import { useOnlineStatus } from "@/hooks/useOnlineStatus";

export function OfflineBanner() {
  const { isOnline, pendingMutations } = useOnlineStatus();

  if (isOnline && pendingMutations === 0) return null;

  return (
    <div
      className={`fixed top-0 left-0 right-0 z-50 px-4 py-2 text-center text-sm font-medium transition-all duration-300 ${
        isOnline
          ? "bg-yellow-50 text-yellow-800 border-b border-yellow-200"
          : "bg-red-50 text-red-800 border-b border-red-200"
      }`}
    >
      {!isOnline ? (
        <span>
          You are offline. Changes will be saved locally and synced when connectivity returns.
        </span>
      ) : (
        <span>
          Syncing {pendingMutations} pending change{pendingMutations !== 1 ? "s" : ""}...
        </span>
      )}
    </div>
  );
}
```

Add the `<OfflineBanner />` at the top level of the app layout in `App.tsx`:

```tsx
import { OfflineBanner } from "@/components/OfflineBanner";

// In the main App component, add before the router:
function App() {
  return (
    <ErrorBoundary>
      <OfflineBanner />
      <QueryClientProvider client={queryClient}>
        <Router />
        <Toaster />
      </QueryClientProvider>
    </ErrorBoundary>
  );
}
```

---

## Part C — Offline Mutation Queue

### C.1 — Install IndexedDB Wrapper

```bash
npm install idb
```

**Why `idb`**: Lightweight (~1KB gzipped) promise-based wrapper around IndexedDB. No additional dependencies. Works in service workers and main thread.

### C.2 — Create Offline Queue Database

Create `client/src/lib/offlineQueue.ts`:

```ts
import { openDB, type IDBPDatabase } from "idb";

interface QueuedMutation {
  id: string;
  method: string;
  url: string;
  body?: unknown;
  headers?: Record<string, string>;
  timestamp: number;
  retryCount: number;
  /** Max retries before dropping */
  maxRetries: number;
  /** Descriptive label for UI display */
  label: string;
}

const DB_NAME = "claims-iq-offline";
const DB_VERSION = 1;
const STORE_NAME = "mutation-queue";

let dbPromise: Promise<IDBPDatabase> | null = null;

function getDb() {
  if (!dbPromise) {
    dbPromise = openDB(DB_NAME, DB_VERSION, {
      upgrade(db) {
        if (!db.objectStoreNames.contains(STORE_NAME)) {
          const store = db.createObjectStore(STORE_NAME, { keyPath: "id" });
          store.createIndex("timestamp", "timestamp");
        }
      },
    });
  }
  return dbPromise;
}

/** Add a mutation to the offline queue */
export async function enqueueMutation(
  mutation: Omit<QueuedMutation, "id" | "timestamp" | "retryCount">
): Promise<string> {
  const db = await getDb();
  const id = crypto.randomUUID();
  const entry: QueuedMutation = {
    ...mutation,
    id,
    timestamp: Date.now(),
    retryCount: 0,
  };
  await db.add(STORE_NAME, entry);
  updateQueueCount();
  return id;
}

/** Get all pending mutations, ordered by timestamp */
export async function getPendingMutations(): Promise<QueuedMutation[]> {
  const db = await getDb();
  return db.getAllFromIndex(STORE_NAME, "timestamp");
}

/** Remove a successfully processed mutation */
export async function removeMutation(id: string): Promise<void> {
  const db = await getDb();
  await db.delete(STORE_NAME, id);
  updateQueueCount();
}

/** Increment retry count, or remove if max retries exceeded */
export async function markRetry(id: string): Promise<boolean> {
  const db = await getDb();
  const entry = await db.get(STORE_NAME, id);
  if (!entry) return false;

  entry.retryCount += 1;
  if (entry.retryCount >= entry.maxRetries) {
    await db.delete(STORE_NAME, id);
    updateQueueCount();
    return false; // Dropped
  }

  await db.put(STORE_NAME, entry);
  return true; // Will retry
}

/** Get count of pending mutations */
export async function getQueueCount(): Promise<number> {
  const db = await getDb();
  return db.count(STORE_NAME);
}

/** Update localStorage count for cross-component reactivity */
async function updateQueueCount() {
  const count = await getQueueCount();
  localStorage.setItem("offline-queue-count", String(count));
  // Dispatch custom event for same-tab listeners
  window.dispatchEvent(new Event("offline-queue-changed"));
}

/** Clear entire queue (use for debugging/reset) */
export async function clearQueue(): Promise<void> {
  const db = await getDb();
  await db.clear(STORE_NAME);
  updateQueueCount();
}
```

### C.3 — Create Queue Processing Hook

Create `client/src/hooks/useOfflineSync.ts`:

```ts
import { useEffect, useRef, useCallback } from "react";
import { useOnlineStatus } from "./useOnlineStatus";
import {
  getPendingMutations,
  removeMutation,
  markRetry,
} from "@/lib/offlineQueue";
import { useToast } from "@/hooks/use-toast";

/** Interval between sync attempts when online (ms) */
const SYNC_INTERVAL = 10000; // 10 seconds

/** Hook that processes the offline mutation queue when online */
export function useOfflineSync() {
  const { isOnline } = useOnlineStatus();
  const { toast } = useToast();
  const isProcessingRef = useRef(false);

  const processQueue = useCallback(async () => {
    if (isProcessingRef.current || !navigator.onLine) return;
    isProcessingRef.current = true;

    try {
      const pending = await getPendingMutations();
      if (pending.length === 0) {
        isProcessingRef.current = false;
        return;
      }

      let successCount = 0;
      let failCount = 0;

      for (const mutation of pending) {
        try {
          const response = await fetch(mutation.url, {
            method: mutation.method,
            headers: {
              "Content-Type": "application/json",
              ...mutation.headers,
            },
            body: mutation.body ? JSON.stringify(mutation.body) : undefined,
            signal: AbortSignal.timeout(15000),
          });

          if (response.ok) {
            await removeMutation(mutation.id);
            successCount++;
          } else if (response.status >= 400 && response.status < 500) {
            // Client error — don't retry (bad data)
            await removeMutation(mutation.id);
            failCount++;
            console.warn(
              `Offline mutation dropped (${response.status}):`,
              mutation.label
            );
          } else {
            // Server error — retry later
            const willRetry = await markRetry(mutation.id);
            if (!willRetry) failCount++;
          }
        } catch (err) {
          // Network error — stop processing, wait for next interval
          console.debug("Offline sync: network error, will retry", err);
          break;
        }
      }

      if (successCount > 0) {
        toast({
          title: "Changes synced",
          description: `${successCount} offline change${successCount !== 1 ? "s" : ""} saved to server.`,
        });
      }
      if (failCount > 0) {
        toast({
          title: "Some changes failed",
          description: `${failCount} change${failCount !== 1 ? "s" : ""} could not be synced and ${failCount !== 1 ? "were" : "was"} dropped.`,
          variant: "destructive",
        });
      }
    } finally {
      isProcessingRef.current = false;
    }
  }, [toast]);

  // Process queue when coming back online
  useEffect(() => {
    if (isOnline) {
      processQueue();
    }
  }, [isOnline, processQueue]);

  // Periodic sync when online
  useEffect(() => {
    if (!isOnline) return;

    const interval = setInterval(processQueue, SYNC_INTERVAL);
    return () => clearInterval(interval);
  }, [isOnline, processQueue]);

  return { processQueue };
}
```

### C.4 — Integrate Queue with API Client

Modify `client/src/lib/queryClient.ts` to automatically queue failed mutations when offline.

First, **export** the `getAuthHeaders` function (currently private at line 4). Change:

```ts
async function getAuthHeaders() {
```

to:

```ts
export async function getAuthHeaders() {
```

Then add the resilient mutation wrapper after the `apiRequest` function:

```ts
// ADD to queryClient.ts, after the apiRequest function:

import { enqueueMutation } from "./offlineQueue";

/**
 * Wrapper around apiRequest that queues mutations when offline.
 * Use this for non-critical mutations that can be safely retried.
 */
export async function resilientMutation(
  method: string,
  url: string,
  data?: unknown,
  options?: {
    /** Human-readable label for the queue UI */
    label?: string;
    /** Max retries if request fails (default: 5) */
    maxRetries?: number;
    /** If true, never queue — always throw on failure */
    skipQueue?: boolean;
  }
): Promise<Response> {
  try {
    return await apiRequest(method, url, data);
  } catch (err: any) {
    // If online, propagate the error normally
    if (navigator.onLine || options?.skipQueue) {
      throw err;
    }

    // Offline: queue the mutation for later
    const authHeaders = await getAuthHeaders();
    await enqueueMutation({
      method,
      url,
      body: data,
      headers: authHeaders,
      maxRetries: options?.maxRetries ?? 5,
      label: options?.label || `${method} ${url}`,
    });

    // Return a synthetic "queued" response so the UI can continue
    return new Response(
      JSON.stringify({ queued: true, message: "Saved offline — will sync when connected" }),
      { status: 202, headers: { "Content-Type": "application/json" } }
    );
  }
}
```

### C.5 — Update Critical Mutations to Use Resilient Client

In `client/src/pages/ActiveInspection.tsx`, update the voice tool handlers that call the API to use `resilientMutation` for non-voice operations:

```tsx
// IMPORT at top of ActiveInspection.tsx:
import { resilientMutation } from "@/lib/queryClient";

// Example: When tool call creates a room (in executeToolCall handler):
case "create_room": {
  const response = await resilientMutation(
    "POST",
    `/api/inspection/${sessionId}/rooms`,
    args,
    { label: `Create room: ${args.name}` }
  );
  const room = await response.json();
  result = { success: true, roomId: room.id };
  break;
}

// Example: When tool call adds a damage observation:
case "add_damage": {
  const response = await resilientMutation(
    "POST",
    `/api/inspection/${sessionId}/damages`,
    { ...args, roomId: currentRoomId },
    { label: `Record damage: ${args.description?.substring(0, 40)}` }
  );
  const damage = await response.json();
  result = { success: true, damageId: damage.id };
  break;
}

// Example: When tool call adds a line item:
case "add_line_item": {
  const response = await resilientMutation(
    "POST",
    `/api/inspection/${sessionId}/line-items`,
    { ...args, roomId: args.roomId || currentRoomId },
    { label: `Add line item: ${args.description?.substring(0, 40)}` }
  );
  const item = await response.json();
  result = { success: true, lineItemId: item.id };
  break;
}
```

**Note**: Voice session creation (`POST /api/realtime/session`) and session completion (`POST /api/inspection/:sessionId/complete`) should NOT use `resilientMutation` — these require real-time responses and cannot be meaningfully queued.

---

## Part D — Service Worker Enhancement

### D.1 — Custom Service Worker for Background Sync

The current Workbox-generated service worker handles asset caching. Extend it to support background sync for the offline mutation queue.

Update `vite.config.ts` to inject custom service worker logic:

```ts
// In the VitePWA configuration, update the workbox section:
VitePWA({
  // ... existing config ...
  workbox: {
    // ... existing globPatterns and runtimeCaching ...

    // Add custom service worker code for background sync
    importScripts: ["sw-offline-sync.js"],
  },
})
```

### D.2 — Create Custom Service Worker Extension

Create `public/sw-offline-sync.js` (create the `public/` directory if it doesn't exist — Vite serves static files from this directory):

```js
/**
 * Service worker extension for offline mutation queue processing.
 * Imported by the Workbox-generated service worker via importScripts.
 */

// Listen for sync events (triggered when connectivity returns)
self.addEventListener("sync", (event) => {
  if (event.tag === "offline-mutation-sync") {
    event.waitUntil(processOfflineQueue());
  }
});

// Listen for messages from the main thread
self.addEventListener("message", (event) => {
  if (event.data && event.data.type === "PROCESS_QUEUE") {
    processOfflineQueue();
  }
});

async function processOfflineQueue() {
  // Open IndexedDB from service worker context
  const db = await openIndexedDB();
  if (!db) return;

  const tx = db.transaction("mutation-queue", "readwrite");
  const store = tx.objectStore("mutation-queue");
  const index = store.index("timestamp");

  const mutations = await getAllFromIndex(index);

  for (const mutation of mutations) {
    try {
      const response = await fetch(mutation.url, {
        method: mutation.method,
        headers: {
          "Content-Type": "application/json",
          ...mutation.headers,
        },
        body: mutation.body ? JSON.stringify(mutation.body) : undefined,
      });

      if (response.ok || (response.status >= 400 && response.status < 500)) {
        // Success or client error (don't retry) — remove from queue
        const deleteTx = db.transaction("mutation-queue", "readwrite");
        deleteTx.objectStore("mutation-queue").delete(mutation.id);
        await deleteTx.done;
      }
    } catch {
      // Network still down — stop processing
      break;
    }
  }

  db.close();
}

function openIndexedDB() {
  return new Promise((resolve) => {
    const request = indexedDB.open("claims-iq-offline", 1);
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => resolve(null);
  });
}

function getAllFromIndex(index) {
  return new Promise((resolve) => {
    const request = index.getAll();
    request.onsuccess = () => resolve(request.result || []);
    request.onerror = () => resolve([]);
  });
}
```

### D.3 — Register Background Sync

In `client/src/lib/offlineQueue.ts`, add a function to request background sync:

```ts
// ADD to the end of offlineQueue.ts:

/** Request background sync via service worker (if supported) */
export async function requestBackgroundSync(): Promise<void> {
  if ("serviceWorker" in navigator && "SyncManager" in window) {
    const registration = await navigator.serviceWorker.ready;
    try {
      await (registration as any).sync.register("offline-mutation-sync");
    } catch {
      // Background sync not supported or permission denied — fallback to polling
      console.debug("Background sync registration failed, using polling fallback");
    }
  }
}
```

Call `requestBackgroundSync()` whenever a mutation is added to the queue:

```ts
// In the enqueueMutation function, after adding to IndexedDB:
export async function enqueueMutation(...) {
  // ... existing code ...
  await db.add(STORE_NAME, entry);
  updateQueueCount();
  requestBackgroundSync(); // NEW: trigger sync when connectivity returns
  return id;
}
```

---

## Part E — Mount the Offline Sync Hook

### E.1 — Add to App Root

In `client/src/App.tsx`, mount the sync hook at the app level so it processes the queue globally:

```tsx
import { useOfflineSync } from "@/hooks/useOfflineSync";

// Inside the App component (or a wrapper component inside QueryClientProvider):
function AppWithSync() {
  useOfflineSync();
  return <Router />;
}

// Update the App render:
function App() {
  return (
    <ErrorBoundary>
      <OfflineBanner />
      <QueryClientProvider client={queryClient}>
        <AppWithSync />
        <Toaster />
      </QueryClientProvider>
    </ErrorBoundary>
  );
}
```

---

## Summary of All Changes

| File | Change Type | Description |
|------|------------|-------------|
| `client/src/App.tsx` | MODIFY | Convert page imports to `React.lazy`, add `Suspense` boundary, add `OfflineBanner`, mount `useOfflineSync`, add route-level `ErrorBoundary` wrappers |
| `client/src/components/ErrorBoundary.tsx` | CREATE | Reusable error boundary with inline/full-page modes and retry support |
| `client/src/components/OfflineBanner.tsx` | CREATE | Fixed-position banner showing offline status and pending mutation count |
| `client/src/hooks/useOnlineStatus.ts` | CREATE | Hook tracking navigator.onLine state, pending mutation count, connectivity check |
| `client/src/hooks/useOfflineSync.ts` | CREATE | Hook that processes the IndexedDB mutation queue when online |
| `client/src/lib/offlineQueue.ts` | CREATE | IndexedDB-backed mutation queue with enqueue, process, retry, and background sync |
| `client/src/lib/queryClient.ts` | MODIFY | Add `resilientMutation()` wrapper that queues failed requests when offline |
| `client/src/pages/ActiveInspection.tsx` | MODIFY | Update voice tool handlers to use `resilientMutation` for room/damage/line-item creation |
| `vite.config.ts` | MODIFY | Add `importScripts` for custom service worker extension |
| `public/sw-offline-sync.js` | CREATE | Service worker extension for Background Sync API integration |

**New files**: 6
**Modified files**: 4
**New dependencies**: 1 runtime (idb)
